### 前置准备

断言行为和数据定义于测试用例的测试步骤中, 例如: 
```yaml
config:
    name: "request methods testcase with functions"
    variables:
        foo1: config_bar1
        foo2: config_bar2
        expect_foo1: config_bar1
        expect_foo2: config_bar2
    base_url: "https://postman-echo.com"
    verify: False
    weight: 2
    export: ["foo3"]


teststeps:
-
    name: get with params
    variables:
        foo1: bar11
        foo2: bar21
        sum_v: "${sum_two(1, 2)}"
    request:
        method: GET
        url: /get
        params:
            foo1: $foo1
            foo2: $foo2
            sum_v: $sum_v
        headers:
            User-Agent: HttpRunner/${get_httprunner_version()}
    extract:
        foo3: "body.args.foo2"
    validate:
        - eq: ["status_code", 200]                                                      # 断言在这里
        - eq: ["body.args.foo1", "bar11"]
        - eq: ["body.args.sum_v", "3"]
        - eq: ["body.args.foo2", "bar21"]
```
对应于`.py`文件.
```python3
# NOTE: Generated By HttpRunner v3.1.6
# FROM: request_methods/request_with_functions.yml


from httprunner import HttpRunner, Config, Step, RunRequest, RunTestCase


class TestCaseRequestWithFunctions(HttpRunner):

    config = (
        Config("request methods testcase with functions")
        .variables(
            **{
                "foo1": "config_bar1",
                "foo2": "config_bar2",
                "expect_foo1": "config_bar1",
                "expect_foo2": "config_bar2",
            }
        )
        .base_url("https://postman-echo.com")
        .verify(False)
        .export(*["foo3"])
        .locust_weight(2)
    )

    teststeps = [
        Step(
            RunRequest("get with params")
            .with_variables(
                **{"foo1": "bar11", "foo2": "bar21", "sum_v": "${sum_two(1, 2)}"}
            )
            .get("/get")
            .with_params(**{"foo1": "$foo1", "foo2": "$foo2", "sum_v": "$sum_v"})
            .with_headers(**{"User-Agent": "HttpRunner/${get_httprunner_version()}"})
            .extract()
            .with_jmespath("body.args.foo2", "foo3")
            .validate()
            .assert_equal("status_code", 200)                                           # 断言在这里
            .assert_equal("body.args.foo1", "bar11")
            .assert_equal("body.args.sum_v", "3")
            .assert_equal("body.args.foo2", "bar21")
        )
    ]


if __name__ == "__main__":
    TestCaseRequestWithFunctions().test_start()

```

&nbsp;  
### httprunner框架的断言是怎么工作的?  

- 调用栈
```shell
httprunner.runner.HttpRunner.test_start#455
httprunner.runner.HttpRunner.run_testcase#359
httprunner.runner.HttpRunner.__run_step#295
httprunner.runner.HttpRunner.__run_step_request#208
httprunner.response.ResponseObject.validate#207

```

- validate

主要是围绕 `requests.response` 的 `status_code`、`headers`、`cookies`、`body` 这四个内容进行数据搜索.  
通过代码手段将上述四个字段的内容合并成一个大的字典, 利用 jmespath 对这个大字典进行搜索, 提取对应的值然后跟期望值做比较.  

```python3


class ResponseObject(object):
    def __init__(self, resp_obj: requests.Response):
        """ initialize with a requests.Response object

        Args:
            resp_obj (instance): requests.Response instance

        """
        self.resp_obj = resp_obj
        self.validation_results: Dict = {}

    def validate(
        self,
        validators: Validators,
        variables_mapping: VariablesMapping = None,
        functions_mapping: FunctionsMapping = None,
    ) -> NoReturn:

        variables_mapping = variables_mapping or {}
        functions_mapping = functions_mapping or {}

        self.validation_results = {}
        if not validators:
            return

        validate_pass = True
        failures = []

        for v in validators:

            if "validate_extractor" not in self.validation_results:
                self.validation_results["validate_extractor"] = []

            # 将断言数据打平
            # from
            # {'equal': ['status_code', 200, '']}
            # to 
            # {'check': 'status_code', 'expect': 200, 'assert': 'equal', 'message': ''}
            u_validator = uniform_validator(v)

            # check item 
            # check_item == u_validator["check"] == "status_code"
            # 如果 "status_code" 字符串中有引用了变量或者调用了函数, 这段代码就是负责解析变量和执行执行函数的作用.
            check_item = u_validator["check"]
            if "$" in check_item:
                # check_item is variable or function
                check_item = parse_data(
                    check_item, variables_mapping, functions_mapping
                )
                check_item = parse_string_value(check_item)

            # 当 check_item 不是 ["status_code", "headers", "cookies", "body"] 这四个字符串时, 将不会触发jmespath的搜索动作.
            # 否则将会使用jmespath尝试搜索到正确的值; 这里属于准备工作还不是做值比较的时候.
            # jmespath 使用方法: https://www.cnblogs.com/rongfengliang/p/9568390.html
            if check_item and isinstance(check_item, Text):
                check_value = self._search_jmespath(check_item)
            else:
                # variable or function evaluation result is "" or not text
                check_value = check_item

            # comparator
            # 从 httprunner.builtin.comparators 里匹配对应的比较函数
            assert_method = u_validator["assert"]
            assert_func = get_mapping_function(assert_method, functions_mapping)

            # expect item
            # 如果 expect 字符串中有引用了变量或者调用了函数, 这段代码就是负责解析变量和执行执行函数的作用.
            expect_item = u_validator["expect"]
            # parse expected value with config/teststep/extracted variables
            expect_value = parse_data(expect_item, variables_mapping, functions_mapping)

            # message
            # 如果 message 字符串中有引用了变量或者调用了函数, 这段代码就是负责解析变量和执行执行函数的作用.
            message = u_validator["message"]
            # parse message with config/teststep/extracted variables
            message = parse_data(message, variables_mapping, functions_mapping)

            # 为断言失败准备报错文案.
            validate_msg = f"assert {check_item} {assert_method} {expect_value}({type(expect_value).__name__})"

            validator_dict = {
                "comparator": assert_method,
                "check": check_item,
                "check_value": check_value,
                "expect": expect_item,
                "expect_value": expect_value,
                "message": message,
            }

            try:
                # 执行断言
                assert_func(check_value, expect_value, message)
                validate_msg += "\t==> pass"
                logger.info(validate_msg)
                validator_dict["check_result"] = "pass"
            except AssertionError as ex:
                # 断言失败
                validate_pass = False
                validator_dict["check_result"] = "fail"
                validate_msg += "\t==> fail"
                validate_msg += (
                    f"\n"
                    f"check_item: {check_item}\n"
                    f"check_value: {check_value}({type(check_value).__name__})\n"
                    f"assert_method: {assert_method}\n"
                    f"expect_value: {expect_value}({type(expect_value).__name__})"
                )
                message = str(ex)
                if message:
                    validate_msg += f"\nmessage: {message}"

                logger.error(validate_msg)
                failures.append(validate_msg)

            # 将执行结果写入到ResponseObject.validation_results["validate_extractor"] 中.
            self.validation_results["validate_extractor"].append(validator_dict)

        if not validate_pass:
            failures_string = "\n".join([failure for failure in failures])
            raise ValidationFailure(failures_string)

```