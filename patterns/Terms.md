### 可用性
[可用性](http://www.uml.org.cn/softwareprocess/rjgc18.htm) 是衡量使用一种产品来执行指定任务的难易程度的尺度.

### 功能性需求
由参与者(人、另一个系统、计时器、传感器等)发起的一个任务, 该任务完成一件事情, 这就是功能性需求, page-45.   

### 可用性需求  
系统界面要很友好, 在每个页面上都有操作提示, 这就是可用性需求, page-81.  

### 涉众(Stakeholder)  
参与者是涉众代表, 例如要建立一个办公自动化系统, 这个系统将为所有的办公室员工归档和查找文件带来利益.  
但是并不需要把所有的办公室员工都找来咨询需求, 一个称之为"文员"的参与者可以代表这批涉众来向系统提出  
如何归档和如何查询的要求, 一次来获得涉众利益, page-49.  

### 高内聚  
避免边界外的事物频繁的直接访问边界内的元素, page-77.   

### 低耦合  
对象与对象之间的依赖关系(双向依赖、交叉依赖)越紧密表示着耦合越高.  
单向依赖、无依赖通常表示为低耦合, page-77.  

### 对象(Object)
对象对应于编程语言中的类, 而我们都知道类是由多个属性(数据)和多个方法构成的, [参考资料](https://www.techtarget.com/searchapparchitecture/definition/object).  

### 对象实例
场景中的对象只是该对象的一个侧面, 我们称之为对象实例, page-37.  
通过一个场景, 我们仅能得到该对象的一个侧面信息.  
要深入了解对象, 我们经常需要分析很多个与该对象强相关的场景.

### 业务对象(Business Object)  
业务对象对应于现实世界中的人、地点或事物.  
业务对象的定义侧重点在对象的属性、方法以及业务对象间的关系, page-16、[参考资料](https://flylib.com/books/en/2.699.1.19/1/).  

### 用例(Use Case)
用例对应于日常工作的测试用例, page-52.
> **用例**  
> 你想做一顿饭吃, 你需要完成煮饭和炒菜两件事情, 这两件事情就是两个用例.  
> 
> **用例的实例**  
> 煮饭这件事情是可以有不同做法的, 你可以用电饭煲煮饭,   
> 也可以用蒸笼蒸饭, 这是两个不同的场景, 也就是两个用例的实例.    
> 
> **用例在不同条件下的不同处理场景**  
> 同样是用电饭煲煮饭, 如果是粗米, 你需要先淘米, 然后再下锅.  
> 如果是精米, 则可以省略淘米步骤直接下锅.  
> 这是用例在不同条件下的不同处理场景.  
> 
> **结论**  
> 根据上面三个描述片段, 有效的用例时2个(就是那两个用例的实例).   
> 然而在实际工作中, 通常会产出4个有效的用例:   
> 1). 用电饭煲煮饭, 粗米, 算一个用例.  
> 2). 用电饭煲煮饭, 精米, 算一个用例.  
> 3). 用蒸笼煮饭, 算一个用例.  
> 4). 炒菜, 算一个用例.
 
### 业务用例(Business Use Case)
业务用例(Business Use Case) == 用例(Use Case),  
所以后续业务用力统统会被成为用例.  
[参考资料-1](https://stackoverflow.com/a/3294069) 、
[参考资料-2](https://sceweb.uhcl.edu/helm/RationalUnifiedProcess/process/modguide/md_buc.htm) 、
[参考资料-3](https://sceweb.uhcl.edu/helm/RationalUnifiedProcess/process/modguide/md_uc.htm)    

### 用例实例(Use Case Instance)  
用例实例 == 业务用例实现(Business use case realization),  
就像对象实例与之对象, 一个用例实例也只是用例的一个侧面.  
`Pytest`的参数化就是一组用例实例, 用于验证用例的完整性.    
page-68, [参考资料-1](https://sceweb.uhcl.edu/helm/RationalUnifiedProcess/process/modguide/md_uc.htm)

### 概念用例
TODO: 资料不充分, 表达不清楚, 后续需要精简或重写这里.  
概念用例用来表示核心业务逻辑, 这些核心业务逻辑揭示了业务模式, 成为业务框架的重要知道, page-69.

### 系统用例  
业务用例: 以参与者的目标来描述所有操作步骤, 侧重点是参与者输入什么, 系统输出什么.   
系统用例: 以参与者和系统的角色来描述所有操作步骤, 侧重点是参与者在不同的角色下能做什么, 系统分别输出什么.  

### 用例实现
一个用例实现代表了用例的一种实现方式, page-70.  
用例实现描述的是用例实现的过程, 先干嘛, 再干嘛, 最后干嘛.  

### 领域模型  
领域模型描述那些对业务有着重要意义的业务对象, page-112.  

### 结构化编程(SP)  
结构化编程, 英文简称: SP; 英文全称: [Structured programming](https://en.wikipedia.org/wiki/Structured_programming).  
结构化编程强调在程序入口处充分利用 `if`、`if else`、`for loop`、`while`、`struct` 等特性完成需求代码的开发, page-1.  
> 结构化编程, 适用于卡片编程时代(20世纪60年代).  

### 面向过程编程(OPP)  
面向过程编程, 英文简称: OPP; 英文全称: [Procedural Oriented Programming](https://www.geeksforgeeks.org/differences-between-procedural-and-object-oriented-programming/).  
在`结构化编程`的基础上, 将动作最小化封装成函数, 每个函数表示一个操作步骤,     
每个动作都是一个函数调用, 并且函数和函数之间对数据的承接有严格的要求;  
结构化的数据要么是全局共享的, 要么是通过指针形式传递给函数;  
面向过程编程强调由控制函数来统筹调用所有步骤函数来完成需求代码的开发, page-3.  
> 面向过程编程, 适用于小规模编程时代(20世纪60、70、80年代).  
> 在20世纪90年代以前盛行的过程式编程, 是非常面向机器的.  
> 开发人员需要对计算机如何工作有相当多的了解, 才能写出好代码.  
> 
> 补充: httprunner 这个框架是面向过程编程的.  


### 面向对象编程(OOP)
面向对象编程, 英文简称: OOP; 英文全称: [Object Oriented Programming](https://www.geeksforgeeks.org/differences-between-procedural-and-object-oriented-programming/)  
面向对象编程是继结构化革命之后的又一次软件开发方式革命, 面向对象的主要思想是基于抽象数据类型的(Abstract Data Type, ADT):   
在结构化编程过程中, 人们发现把某种数据结构和用于操纵它的各种操作以某种模块化方式绑定到一起会非常方便, [参考来源](https://blog.csdn.net/Edward_Wong/article/details/39533245).  
面向对象编程还产生了很多的重要概念: `继承`、`接口`、`多态`、`封装`、`方法`、`依赖`、`组合`、`实例化`、`耦合`、`复用` 等, page-7.    
> 面向对象编程, 适用于大规模编程时代(20世纪90年代至今).  
> Python于1991年诞生, 这是一门面向对象语言, 在Python中一切都是对象.  
> wxPython这个三方库于1994年诞生, 这是框架的采取面向对象的编程规范来进行封装.  

### 面向过程与面向对象的区别  
参考这里: [Difference between Procedural Programming and Object Oriented Programming](https://www.geeksforgeeks.org/differences-between-procedural-and-object-oriented-programming/)

|差异|面向过程|面向对象|
|---|---|---|
|代码封装|代码封装在函数中|代码封装在类的方法中|
|设计方法|遵循自顶向下方法|遵循自底向上方法|
|访问控制|-|`private`、`public`、`protect`|
|流程或数据变更|改动大|改动小|
|数据安全|数据都是公开的|类数据默认都是私有的, <br />通过显式声明公开来访问, <br />通过方法代理访问, <br />通过方法代理修改. |
|多态机制|-|支持多态机制|
|侧重点-1|认为函数比数据重要|认为类的数据比类的方法重要|
|侧重点-2|面向操作系统的API来设计和开发|面向现实世界的对象和关系来设计、抽象和开发|

### 统一过程(RUP)
统一过程, 英文简称: RUP; 英文全称: Rational Unified Process.  
RUP集成了面向对象方法、UML语言、核心工作流、工作模板和过程指导等许多知识.  
RUP要求在写代码之前, 需要先将需求分析清楚并转换成设计文档(含: 流程图、时序图、状态图、类图等).    
RUP适用于开发稳定的架构, 它通过不断的演进来逐步推进软件产品, 这一特点使得它特别适合长期战略的软件产品.  
RUP适合那些想长期立足于做某个行业, 希望做精做深, 做行业整体解决方案的企业(组织), page-22.  

### 极限编程(XP)  
极限编程, 英文简称: XP; 英文全称: Extreme Programming.
XP的核心思想是利用单元测试、系统测试体系来做每日构建, 尽早的暴露问题、发现错误,   
降低问题随着时间的推移而不断增加的复杂度, 从而达到节约成本的效果.  
XP强调将一个大的任务拆解成可以在较短周期解决的一个个子任务,   
通过一个个短小的迭代周期, 可以获得一个个阶段性的进展, page-26.  

### 统一过程与极限编程的区别  
如果用XP方法来开发F-35战斗机将会是一个什么情形, 没有人清楚地知道将来飞机的整体是什么样,   
好不容易设计出机翼来, 另一个小组说我们决定改变一下气动外形, 你们再重构一下把;   
没有人知道最后飞机的性能怎么样, 反正先造一架出来, 要是摔了找找原因, 改进改进,   
重构一下, 在造一架, 再摔了, 没关系, 咱们拥抱变化, 再造就是了...   
显然对这种大型产品来说XP方法是不可接受的, 而RUP的稳步推进的方法正好适合这种场景.  

如果你是一个杂货店的老板, 刚开业不知道什么样的商品受欢迎, 没关系, 先各进一小批货,   
卖上一段时间, 受欢迎的货品多进, 不受欢迎的不进, 随时向顾客做一些调查,  
顾客喜欢什么就进什么, 不断改进, 最后一定会顾客盈门的, XP方法就比较适合这种场景.

如果杂货店场景采用RUP方法, 先做商业分析、客户关系分析、消费曲线分析,   
还没开业呢, 估计就破产了, 或者好不容易做出了一个商业策略, 客户兴趣已经改变了.    

上面介绍了它们的差异, 但是实际工作中我发现它们是紧密融合的,   
在做底层框架开发的时候采用RUP方法, 而在做一些具体功能的时候可以采用XP方法.   

> **最佳实践**  
> 对于软件产品来说, 最佳实践来自两个方面: 一方面是技术类的, 如设计模式;   
> 另一方面是过程类的, 如需求方法、分析方法、设计方法等.  
> RUP继承了很多过程类的最佳实践, 这些最佳实践中包括用例驱动、架构导向、构件化等.  
> 学习RUP将了解到软件的本质, 对提升软件"智商"是非常有好处的.  


### 抽象(abstract)  
从众多具体事物中, 抽取共同的属性, 舍弃个别的属性, 这个动作被称为抽象.  
从编程的角度来看, 抽象对应的就是公共接口(`Interface`).  

**抽象角度**  
请在30秒内尽可能多的说出筷子、勺子和盘子的相同点和不同点.  

- 从用途的角度去抽象   
  它们的相同点是三者都是餐具, 不同点是筷子是用来夹的, 勺子是用来舀的, 盘子是用来盛的.   
  > 举例:  
  > 当从用途的角度去抽象时, 在脑子里为这三个事物建立起了一个人用餐的业务逻辑模型,   
  > 并且这三者在这个业务逻辑模型中表现出了各自的职责和特别的属性.  


- 从使用的角度去抽象  
  它们的相同点是都需要用手去拿, 不同的是手的动作不同.


- 从字面的角度去抽象  
  它们的相同点是都带了一个"子"字.  



所以从不同的角度抽象可以得出不同的结果, 当我们试图为现实世界建模的时候, 首先要决定的是抽象角度,   
即: 建立这个模型的目的是什么, 一旦抽象角度确定, 剩下的事情就变得顺利成章, 而不再是杂乱无章.    

当我们试图去分析需求、面对大量需求资料时, 是否有时候感觉到无从下手?   
当我们试图去做一个设计时, 是否有时候感觉到力不从心?  
这个时候与其说是分析经验不足或是设计能力不够, 不如说是你还没有找到明确的抽象角度.  
面向对象与面向过程不同的地方是, 面向过程希望你通盘考虑, 这时问题变得复杂化;  
而面对象希望你把事务通过抽象角度分解成小块, 问题就变得简单化.  
正如上面的小测试, 在没有明确抽象角度之前, 大部分面试者都会很慌张,   
不明白面试官为什么要问这样一个问题, 不知道从哪里回答, 也不知道回答得是否准确.    
如果加一个条件, 编程请在30秒内说出在使用上: 筷子、勺子、盘子有什么相同点和不同点,  
这个问题就会变得很容易回答了.  

**抽象方法**  
抽象有两种方法, 一种是自顶向下, 另一种是自底向上.   

- 自顶向下  
  自顶向下的方法适用于人们从头开始认识一个事物,   
  例如介绍汽车的工作原理时, 从发动机、传动装置、变速器等较高层次的抽象概念来讲就比较容易明白.  
  如果降一个层次, 从发动机原理讲起, 一大部分听众就会开始迷惑.  
  再降一个层次, 从热力学原理和力学原理讲起, 那就更没人能搞懂汽车是怎么工作的了.   


- 自底向上  
  自顶向下的方法适用于在实践中改进和提高认识,   
  例如在实践中发现了发动机的问题, 因而改进发动机结构, 甚至采用新的发动机原理, 最终能够提升汽车的质量.  

在软件开发过程中, 主题上应当采用**自顶向下**的方法, 用少量的概念覆盖系统需求, 再逐步降低抽象层次, 直到代码编写.  
同时应当辅以自底向上的方法, 通过总结在较低抽象层次的实践经验来改进较高层次的概念以提升软件质量.  



### 建模

建立模型的关键就是弄明白有什么人, 什么人做什么事, 什么事产生什么物, 中间有什么规则,  
再把人、事、物之间的关系定义出来, 一个模型也就基本成型了.  

> **方法论:**  
> 1. 将`文字描述`转换成`业务模型`: 抽象出人、事、物、规则.
> 2. 将`业务模型`转换成`概念模型`: 抽象出(对象的)边界、(对象的)实体、(业务的流向)控制.
> 3. 将`概念模型`转换成`设计模型`: 抽象出(边界)接口、(实体)数据对象、(控制)算法.    

**业务模型**  
需求方(`actor`)是业务信息的第一驱动者(**人**), 即: 整个需求场景开始的地方.  
用例(`use case`)是描述驱动者的目标(**事**), 即: 想要做什么并且获得什么效果.  
场景(`scenario`)是描述场景的过程(**规则**), 即: 这件事是怎么做的, 依据什么规则.  
对象(`object`)是描述场景流转过程需要哪些对象(**物**), 即: 达成这些业务目标的过程中涉及到的事务.

**概念模型**  
计算机的代码可以通过概念模型追溯到原始需求, 概念模型规定了一种高层次的抽象,   
这种抽象是一种指导, 也是一种约束, 实际编码过程中非常容易遵循这种指导和约束来完成代码的设计和落地工作.  
边界类(`boundary`): 对应于现实世界中的"事"(决定了外面能对里面做什么).    
实体类(`entity`): 对应于现实世界中的"物"(描述了物的属性、维度、状态、上下文等).  
控制类(`contrl`): 对应于现实世界中的"规则"(控制边界类和实体类的交互).  
只要有人、事、物和规则(定于), 就能构成一个有意义的结果, 无非是是否合理而已.  

**设计模型**  
概念模型使我们获得了软件的蓝图, 获得了建设软件所需要的所有组成内容以及所有必要细节.  
这就类似于我们已经在图纸上绘制出了一辆汽车所有的零部件, 并且绘制出如何组装这些零部件的步骤.  
设计模型的工作就是建造零部件, 组装汽车的过程.  
设计模型可以将边界类转化为`接口`类.  
设计模型可以将实体类转化为`pydantic`数据对象类.  
设计模型可以将控制类转化为`算法`函数, 业务流程的逻辑和算法都在这里完成.  

### 视图
指的是用UML工具绘制出来的图: 用例图、对象图、类图、包图、活动图、流程图、状态图、时序图等.  

### 视角  
指的是不同工作职责的人会从不同的角度来理解某个需求或者某个功能,   
**例如:** 同一个业务模块, 经理更关系整体业务流程, 业务员更关心表单填写;    
**作用:** 为不同工作职责的人展示他们所关心的那部分视角.  
从信息的展示角度来说, 恰当的视角可以让观察者更容易抓住信息的本质.  
从观察者的角度来说, 观察者只会关心信息中他感兴趣的那一部分视角, 其他视角的信息对他是没有多少用处的.  
因此在展示信息时选择适当的视角并展示给适当的观察者是十分重要的.

### 描述事物的方法
在描述一个事物的时候, 我们可以从以下三个观点出发(page-61):  
1. 这个事物是什么?
2. 这个事物能做什么?
3. 人们能够用这个事物做什么?  

描述一辆自行车的时候, 我们通常这样说明:  

第一, 自行车是一种交通工具, 它由传动系统、刹车系统等部分组成.  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;描述结构性观点, 即事物的客观存在.  

第二, 自行车可以骑行, 可以载物.   
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;描述功能性观点, 说明事物可利用的价值.  

第三, 人们可以用双脚蹬动踏板而向前行进, 可以用手捏合刹车使自行车停下来.  
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;描述使用者观点, 说明事物对于使用者的意义, 以及使用者怎么使用它, 得到什么样的利益.  

对于我们早已熟知的事物来说, 我们可以上述三个方面的观点来描述, 例如自行车这种天天可以看到的东西.  
如果我们要描述的事物是我们并不熟悉的呢?   
对于一个陌生的事物, 我们不大可能先从结构的角度去解释它, 顶多可以通过观察假定出这个事物能做什么.  
如果这个事物是现在还不存在的呢?  
例如正在研制一种全新药品(不存在的事物), 我们既不能从结构上去解释它, 也不能确定它到底能做什么,   
最好的方式是从使用者的观点出发, 描述使用者能用它做什么, 能获得什么.  

> 补充例子:  
> Viagra本来是辉瑞公司研制生产的一种治疗心绞痛的药物, 可现在Viagra变成了人尽皆知的威哥,  
> 人们都用它来治疗ED(勃起功能障碍症), 大大出乎研究人员的初衷.  
> 
> 所以对于创造一种还不存在的事物, 最好的方式是从使用者的观点出发,   
> 描述使用者能用它做什么, 能获得什么.  

软件恰恰就是一种还不存在的事物.   
对于正准备开发的软件, 我们不能从结构观点去描述它, 也不能从功能观点去描述它.  
最好的方法就是从使用者的观点去描述它,   
至于功能性观点和结构性观点, 可以通过使用者观点推导出来.  

### 关联关系(Association)
关联关系是一种静态关系, 通常与运行时无关.
关联关系一般不强调关联的方向, 我们默认A和B都是相互"知道"对方的存在.  
关联关系分为: 一对一、一对多、多对多.  
**一对一:** 乘车人和车票之间的一对一是符合"规则"的关系; 公民和身份证之间的一对一是符合"法律"的关系.    
**一对多:** 一个班级和多个学生之间是一对多的关系;  
**多对多:** 班级和老师之间的关系, 一个班级有多个老师, 一个老师也可以带多个班级.  
