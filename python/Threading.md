### 概述
从计算机历史的角度来看,   
1967年, [IBM System/360 Operation System](https://en.wikipedia.org/wiki/OS/360_and_successors#MVT) 推出`Tasks`(**多任务**)工作机制, 这是多线程的雏形.    
1998年, [第一份多核芯片的设计方案问世](https://medium.com/nerd-for-tech/multi-core-processors-53ee2899f90f).  
2001年, [IBM推出了第一颗搭载VLSI(very-large-scale integration)芯片的双核处理器](https://www.ibm.com/ibm/history/ibm100/us/en/icons/power4/).  
2003年, 多线程开始被广泛运用.  

时间线往回拉, 在单核CPU的时代, 如果要同时运行多个任务(使用多进程),   
操作系统内核会利用一些时间轮转算法, 让每个进程轮流来运行一些时间, 场景举例:  
假设在单核CPU的电脑上运行了5个进程, 那么操作系统会让每个进程每次占用CPU的时间是2ms(ms: 毫秒),   
那么一秒钟(1000ms)的时间里, 每个进程都会分别被运行200ms,  
所以从我们的感官上看并没有感觉到很卡顿.  

- 一个进程运行200ms是什么概念?  
  以现在的低电压笔记本电脑(I7处理器4核8线程, 最高频率2.4GHz)来看,  
  **Python**运行一个while循环做数值递增操作, `1秒钟`可以运行`2千万`次计算, `200ms`可以运行`4百万次`计算.  


- 多进程遇到了什么问题?  
  如果要运行独立的进程处理独立的任务, 多进程是完美的解决方案.  
  如果要运行多个进程来写作处理同一个任务, 那么多进程就会存在一些限制, 比如说:   
  多进程的变量(内存)无法共享, 那么数据和状态就需要保存在数据库中,   
  编程的过程中就需要频繁的访问数据库, 网络IO的TCP连接就会称为瓶颈.  


- 多线程解决了什么问题?  
  即便在单核CPU的时代, 多线程也比多进程好用, 因为多线程解决了变量(内存)无法共享的问题.  
  这使得要多进程能做的大部分事情, 多线程也能做; 缺点是多线程不能通过命令行被直观的管理(kill/ps).

时间线回到2003年, 当多核CPU出现之后, 多线程也能像多进程那样同时利用多核CPU的能力，  
并且依旧保持变量(内存)共享的能力; 基于这个原因, 多线程在并发领域开始发光发热.  

但是有个不好的消息是, 可能是受限于动态语言的特征，Python并不支持真正意义上的多线程(ruby、js),   
Python的多线程其实是模仿操作系统内核, 在一个进程内利用时间轮转算法(GIL), 让每个线程轮训的运行一些时间.
