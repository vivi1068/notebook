### 可迭代对象(Iterable)
只要能被 `for` 循环遍历的对象, 都是可迭代对象.

注意: 生成器也是`可迭代对象`!!!!!

|关键字|名称|
|---|---|   
|str|字符串类型|
|list|列表类型|
|tuple|元祖类型|
|dict|字典类型(无序)|
|set|集合类型|
|collections.deque|双向队列类型|-|
|collections.defaultdict|默认值字典|-|
|collections.ordereddict|有序字典|-|


&nbsp;  
### 迭代器(Iterator)
可以遍历 `可迭代对象` 的工具, 都是迭代器.  

|关键字|名称|
|---|---|   
|`for`|一般形式的循环|
|`[i for i in iterable]`|列表推导式的循环|
|`in`|包含的判断|
|`not in`|不包含的判断|
|`map`|遍历可迭代对象的成员, 每次遍历1个成员, 并且每个成员都会传递给回调函数进行处理|
|`reduce`|遍历可迭代对象的成员, 每次遍历2个成员, 并将2个成员都传递给回调函数进行处理|
|`filter`|遍历可迭代对象的成员, 每次遍历1个成员, 并将每个成员都传递给回调函数进行处理|


&nbsp;
### 生成器(Generator)
能被内置函数 `next` 触发并返回结果的对象，就是生成器.  
生成器也是一个`可迭代对象`, 但是它和`list`, `tuple`这种对象的区别是,   
生成器并不一次性产生所有的结果, 而是需要被动的触发才会返回结果, 这种行为被称为延迟满足, 举例:  

在没有生成器之前, 如果一个100G大小的文件, 里面有100亿行数据, 用 f.readlines() 来读取数据,   
它会从头到尾的读取整个文件, 将每一行数据添加到列表中, 直到将整个文件读取结束.  
这种场景会遇到一个问题, 那就是机器的内存并没有那么大, 当读取的数据塞满内存时, 程序就会OOM.  

生成器就是为了解决类似这样的问题而诞生的一种技术, Python 2.2 之后使用 f.readlines() 其实就是  
一个生成器, 它的工作原理是先给你返回一个 `Generator` 对象, 当你使用 `next` 触发它时, 它才会  
实时的帮你去读取一行数据并返回给你, 当你再次使用 `next`触发它时, 它才再帮你读取另外一行数据并返回给你,   
这就解决了内存不足的问题, 因为采用这种方式它完全不消耗任何内存.  


