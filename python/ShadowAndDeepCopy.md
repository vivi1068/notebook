### 概述
本文试图在[引用](./VariableReference.md)一文的基础上，继续探讨Python如何操作和传递变量。  

当我们在编程的时候, 我们都会定义变量,   
变量通常用来传递给函数, 然后函数根据变量计算出结果,     
或者变量用来写入到一个数据结构中(比如说: 列表、字典).

在默认的情况下, Python帮我们采取完全引用策略来传递变量,   
也就是说传递一个变量，其实传递的就是这个变量所指向的值的指针,   
这种方式并不消耗CPU的计算资源, 因此采用完全引用策略是一种高效的策略.

### 常量值
在整个程序的完整生命周期中只会创建一次的变量被称为常量.   
`str`、`int`、`float`、`bool` 这四个类型的值都是常量值，下面的例子中不论怎么操作都不会再创建一个新的值.  
```python3
import copy


a = "cpython"               # 创建常量
b = a                       # 引用
c = copy.copy(a)            # 浅拷贝
d = copy.deepcopy(a)        # 深拷贝
id(a)                       # 140444174514096
id(b)                       # 140444174514096
id(c)                       # 140444174514096
id(d)                       # 140444174514096


a = 10                      # 创建常量
b = a                       # 引用
c = copy.copy(a)            # 浅拷贝
d = copy.deepcopy(a)        # 深拷贝
id(a)                       # 4508615568
id(b)                       # 4508615568
id(c)                       # 4508615568
id(d)                       # 4508615568


a = 2.4                     # 创建常量
b = a                       # 引用
c = copy.copy(a)            # 浅拷贝
d = copy.deepcopy(a)        # 深拷贝
id(a)                       # 140444174177904
id(b)                       # 140444174177904
id(c)                       # 140444174177904
id(d)                       # 140444174177904


a = True                    # 创建常量
b = a                       # 引用
c = copy.copy(a)            # 浅拷贝
d = copy.deepcopy(a)        # 深拷贝
id(a)                       # 4508212656
id(b)                       # 4508212656
id(c)                       # 4508212656
id(d)                       # 4508212656
```

### 对象值
除了常量值以外，其他一切都是(类)对象; 例如: `class`、`list`、`dict`、`tutple`、`set`、`queue`、`deque`...   
对象的特征是, 每次实例化一个对象都会创建new一个内存, 因此每次实例化一个对象, 它们的`id`都是独立的.  
```python3
a = []                      # 实例化一个列表对象
b = []                      # 实例化一个列表对象
id(a)                       # 140444174708240
id(b)                       # 140444174707680


class Hello:
    def __init__(self):
        self.word = "world"


a = Hello()                 # 实例化一个类对象
b = Hello()                 # 实例化一个类对象
id(a)                       # 140444174633616
id(b)                       # 140444174634640


a = {}                      # 实例化一个类对象
b = {}                      # 实例化一个类对象
id(a)                       # 140444174688160
id(b)                       # 140444174692912
```

### 引用
Python采取完全引用策略, 所以像做下面这种操作, 并不是复制/拷贝, 而是引用.
```python3
a = []                      # 实例化一个列表对象, 变量a的指针指向该列表对象.
b = a                       # 变量b的指针指向a所指向的列表对象.
id(a)                       # 140444174687520
id(b)                       # 140444174687520
```

### 拷贝
如果列表对象的成员都是常量, 浅拷贝、深拷贝得到的结果都是一样的.
```python3
import copy


a = [1, 2, 3]               # 实例化一个列表对象, 变量a的指针指向该列表对象.
b = copy.copy(a)            # 实例化一个列表对象, 创建于变量a相同的指针, 按顺序指向到对应的内存地址.
c = copy.deepcopy(a)        # 实例化一个列表对象, 创建于变量a相同的指针, 按顺序指向到对应的内存地址.
id(a)                       # 140444174658848
id(b)                       # 140444174657728
id(c)                       # 140444174723024
id(a[0])                    # 4508615280    ; 由于成员值是常量, 所以拷贝的是引用.
id(b[0])                    # 4508615280    ; 由于成员值是常量, 所以拷贝的是引用.
id(c[0])                    # 4508615280    ; 由于成员值是常量, 所以拷贝的是引用.
```

### 浅拷贝 
不论列表对象的成员是否含有(嵌套)列表对象, 浅拷贝(`copy.copy` 或 `[:]`)只负责引用列表对象的一维对象, 
```python3
import copy


a = [1, 2, 3, [4, 5, 6]]    # 实例化一个列表对象, 变量a的指针指向该列表对象.
b = copy.copy(a)            # 实例化一个列表对象, 引用变量a的每个成员对象.
id(a[3])                    # 140444174724544
id(b[3])                    # 140444174724544


# 一定要注意, 这里一不小心就容易混淆了.
# 由于b[3]引用a[3], 所以当 a[3][0] 发生变化时, b[3][0] 也会发生变化.
```

### 深拷贝
如果列表对象的成员含有列表对象, 深拷贝负责递归的为每个列表对象重新实例化一次, 然后再引用最终的常量值.
```python3
import copy

a = [1, 2, 3, [4, 5, 6]]    # 实例化一个列表对象, 变量a的指针指向该列表对象.
b = copy.deepcopy(a)        # 实例化一个列表对象, 引用变量a的每个成员对象.
id(a[3])                    # 140444174657728
id(b[3])                    # 140444174724384


# 一定要注意, 这里一不小心就容易混淆了.
# 由于b[3]是重新实例化的李彪, 所以 a[3][0] 发生变化时, b[3][0] 是不会发生变化的.
```


### 结论
1. 不论是浅拷贝还是深拷贝, 都不拷贝最终的常量值, 而是引用.
2. 浅拷贝引用的是一维的成员.
3. 深拷贝递归的创建对象, 只有遇到常量值时会引用.

根据这三个点, 最终总结得出，不论是浅拷贝还是深拷贝，都没有想象中那么耗时.  
耗时的是当数据量巨大是, 实例化对象和计算槽位的事务耗时.