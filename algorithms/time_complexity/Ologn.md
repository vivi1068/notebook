`O(logn)`被称为对数复杂度.   

> 对数  
> 是数学里面的一个算法, 用于对幂结果的逆运算; 例如:   
> 2 ** 3 = 8; 那么 math.log2(8) 逆运算得出的结果是 3.           
> 2 ** 8 = 256; 那么 math.log2(256) 逆运算得出的结果是 8.  
> 2 ** 30 = 1073741824; 那么 math.log2(1073741824) 逆运算得出的结果是 30.

经过上面的描述, 对数复杂度是 n 几何倍数增长, 也不会增大程序的执行趋势.
```python
def main(n):
    ss = 2
    count = 1
    while ss < n:
        ss *= 2              
        count += 1 
    print("count: ", count)


main(100)                           # 循环执行 7次, 执行次数并没有随着 n 的倍增而倍增.
main(1000)                          # 循环执行10次, 执行次数并没有随着 n 的倍增而倍增.
main(10000)                         # 循环执行14次, 执行次数并没有随着 n 的倍增而倍增.
main(100000)                        # 循环执行17次, 执行次数并没有随着 n 的倍增而倍增.
main(1000000)                       # 循环执行20次, 执行次数并没有随着 n 的倍增而倍增.
main(10000000)                      # 循环执行24次, 执行次数并没有随着 n 的倍增而倍增.
main(100000000)                     # 循环执行27次, 执行次数并没有随着 n 的倍增而倍增.
```

&nbsp;  
&nbsp;  

下面这个是带有欺骗性的代码, 这个代码是 `O(n)` 复杂度的代码, 虽然它的if条件只命中了20次, 但是它却执行了100万次.
```python
import math

def main(n):
    count = 1.0
    for i in range(1, n + 1):
        if count == math.log2(i):
            count += 1
            print("hint: ", count)

main(1000000)
``` 